// Generated by CoffeeScript 1.8.0
(function() {
  var IntervalBuffer, assert, sinon;

  IntervalBuffer = require('../interval_buffer');

  sinon = require('sinon');

  assert = require('assert');

  describe('IntervalBuffer', function() {
    var clock;
    clock = null;
    before(function() {
      return clock = sinon.useFakeTimers();
    });
    after(function() {
      return clock.restore();
    });
    describe('constructor', function() {
      return it('should create an empty cache', function() {
        var intervalBuffer;
        intervalBuffer = new IntervalBuffer({
          interval: 100
        }, function() {});
        assert(intervalBuffer.cache instanceof Array, 'did not create an array for the cache');
        return assert.equal(intervalBuffer.cache.length, 0, 'the cache should be empty on initialization');
      });
    });
    describe('push', function() {
      it('should add the item to the cache', function() {
        var intervalBuffer, item;
        intervalBuffer = new IntervalBuffer({
          interval: 100
        }, function() {});
        item = {};
        intervalBuffer.push(item);
        return assert.equal(intervalBuffer.cache[0], item, 'the first element in the cache should have been the one pushed');
      });
      it('should set the time out', function() {
        var intervalBuffer;
        intervalBuffer = new IntervalBuffer({
          interval: 100
        }, function() {});
        intervalBuffer.push({});
        return assert(intervalBuffer.timeoutId, 'did not set a timeout on push');
      });
      it('should call the callback with the aggregate of all push calls made in the span of the timeout', function() {
        var callback, i, intervalBuffer, _i;
        callback = sinon.spy();
        intervalBuffer = new IntervalBuffer({
          interval: 5000
        }, callback);
        for (i = _i = 0; _i < 10; i = ++_i) {
          intervalBuffer.push(i);
        }
        clock.tick(5000);
        assert(callback.calledWith([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), 'the callback was not called with the buffered elements');
        return assert.equal(intervalBuffer.cache.length, 0, 'the cache should be empty after a callback');
      });
      return it('should call the callback with the aggregate of all push calls made when the max size is reached', function() {
        var callback, i, intervalBuffer, _i;
        callback = sinon.spy();
        intervalBuffer = new IntervalBuffer({
          interval: 5000,
          maxSize: 10
        }, callback);
        for (i = _i = 0; _i < 11; i = ++_i) {
          intervalBuffer.push(i);
        }
        assert(callback.calledWith([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), 'the callback was not called with the buffered elements');
        return assert.equal(intervalBuffer.cache.length, 1, 'the cache should have the extra element waiting to be bursted');
      });
    });
    return describe('burst', function() {
      return it('should emit a burst event every time the callback is called', function() {
        var eventHandler, intervalBuffer;
        intervalBuffer = new IntervalBuffer({
          interval: 100
        }, function() {});
        eventHandler = sinon.spy();
        intervalBuffer.on('burst', eventHandler);
        intervalBuffer.push(2);
        clock.tick(100);
        return assert(eventHandler.calledWith(), 'the event handler was not called');
      });
    });
  });

}).call(this);
